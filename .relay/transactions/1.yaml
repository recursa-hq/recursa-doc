uuid: 4899539a-653c-444b-97e3-0c46ab05e81d
projectId: doc
createdAt: '2025-11-04T02:14:21.963Z'
gitCommitMsg: >-
  docs: Refine system prompt and readme for clarity

  - Rewrites `system-prompt.md` to be more concise and easier for an LLM to
  parse. - Replaces all instances of `<tool_call>` with a more intuitive
  `<think>` tag. - Fixes and clarifies the example workflow in `readme.md` to
  demonstrate the agent's reasoning and action loop correctly. - Updates the
  example `.env` configuration in `readme.md` with a valid model name.
promptSummary: >-
  The user wants to improve readme.md and system-prompt.md by making them more
  comprehensive and concise, and replacing `<tool_call>` with `<think>`.
reasoning:
  - >-
    I will update the `readme.md` to be more comprehensive by fixing the example
    workflow, using `<think>` instead of `<tool_call>`, and updating the
    suggested language model. I will also make the `system-prompt.md` more
    concise and clear for the LLM, incorporating the `<think>` tag and
    streamlining the instructions.
  - >-
    First, I will update the `system-prompt.md` to be more concise and easier
    for an LLM to follow. This involves replacing `<tool_call>` with `<think>`,
    shortening the API documentation section, and providing a clearer, more
    direct example workflow.
  - xml
  - <think>
  - '[Your detailed reasoning and plan for the next action.]'
  - </think>
  - <typescript>
  - >-
    [A block of TypeScript code to perform one or more related actions using the
    `mem` API.]
  - </typescript>
  - xml
  - <think>
  - >-
    [Your reasoning that the task is complete and you are now committing the
    work.]
  - </think>
  - <typescript>
  - await mem.commitChanges('[A concise, imperative git commit message]');
  - </typescript>
  - <reply>
  - '[The final, natural language response to the user.]'
  - </reply>
  - xml
  - <think>
  - >-
    The user wants to create a new page. I will use `mem.writeFile` to create a
    file named 'Dr. Eva Rostova.md' with a basic structure.
  - </think>
  - <typescript>
  - await mem.writeFile(
  - '''Dr. Eva Rostova.md'','
  - '''# Dr. Eva Rostova\ntype:: person\n'''
  - );
  - </typescript>
  - xml
  - <think>
  - >-
    I have successfully created the new page. The task is complete. I will now
    commit this change and inform the user.
  - </think>
  - <typescript>
  - 'await mem.commitChanges(''feat: Add entity for Dr. Eva Rostova'');'
  - </typescript>
  - <reply>
  - I've created a new page for Dr. Eva Rostova.
  - </reply>
  - typescript // readme.md search-replace
  - <<<<<<< SEARCH
  - '## An Agent in Action: Example Workflow (Efficient Turns)'
  - '**Scenario:** An agent is asked to learn about a new person.'
  - '**1. User Query:**'
  - >-
    "I just had a call with a Dr. Aris Thorne from the AI Research Institute. He
    works on symbolic reasoning. Create a new entry for him and link it to his
    affiliation."
  - '**2. Real-time Reasoning (Internal LLM <-> Recursa Dialogue):**'
  - '**Turn 1: LLM Output**'
  - '**Turn 1: Recursa Result to LLM**'
  - '**Turn 2: LLM Output**'
  - '**Turn 2: Recursa Result to LLM**'
  - '**Turn 2: LLM Output (Commit and Reply)**'
  - '======='
  - '## An Agent in Action: Example Workflow'
  - '**Scenario:** An agent is asked to learn about a new person.'
  - '**1. User Query:**'
  - >-
    "I just had a call with a Dr. Aris Thorne from the AI Research Institute. He
    works on symbolic reasoning. Create a new entry for him and link it to his
    affiliation."
  - '**2. Turn 1: The agent plans and acts.**'
  - >-
    The LLM receives the query and generates a plan and the corresponding code.
    It decides to check for the organization's existence and create both files
    in one go to be efficient.
  - '**LLM Response (Turn 1):**'
  - '**Recursa executes the code and responds to the LLM:**'
  - '**3. Turn 2: The agent commits its work and replies.**'
  - >-
    The LLM sees that the action was successful. It now generates the final
    response, which includes committing the changes to Git history and replying
    to the user.
  - '**LLM Response (Turn 2):**'
  - '>>>>>>> REPLACE'
  - typescript // readme.md search-replace
  - <<<<<<< SEARCH
  - '# The model you want to use from OpenRouter'
  - LLM_MODEL="openai/gpt-oss-20b"
  - '======='
  - '# The model you want to use from OpenRouter'
  - LLM_MODEL="anthropic/claude-3-sonnet-20240229"
  - '>>>>>>> REPLACE'
  - '```'
operations:
  - type: write
    path: system-prompt.md
    content: >-
      # Recursa Agent System Prompt


      You are Recursa, a Git-Native AI agent. Your mind is a local knowledge
      graph, your actions are TypeScript code, and your memory is a `git`
      history. You do not simply answer questions; you reason, modify the graph,
      and commit your work.


      Your entire existence is defined by the **Think-Act-Commit** loop.


      ---


      ## 1. CRITICAL: Response Format


      Every response you generate MUST conform to the following XML-like
      structure. Failure to adhere to this format will break the execution loop.


      ### Core Tags


      *   `<think>`: Your reasoning, analysis of the user's request, and your
      step-by-step plan. **This tag is mandatory in every turn.**

      *   `<typescript>`: A TypeScript code snippet to be executed in the secure
      sandbox. This is used for all actions.

      *   `<reply>`: The final, user-facing response. **This tag should ONLY be
      used in the very last turn of an operation**, after all actions (including
      the final `commitChanges`) are complete.


      ### Response Patterns


      **Pattern A: Action Turn (Think & Act)**
    patchStrategy: replace
  - type: write
    path: '**Pattern B: Final Turn (Commit & Reply)**'
    content: ''
    patchStrategy: replace
  - type: write
    path: '---'
    content: >-
      ## 2. The `mem` API: Your Sandboxed Toolkit


      You have access to a global `mem` object with asynchronous methods. **ALL
      `mem` calls MUST be `await`ed.** For the complete API reference, read
      `tools.md`.


      **Key Tool Categories:**

      *   **Core File I/O:** `mem.readFile`, `mem.writeFile`, `mem.updateFile`,
      `mem.fileExists`, `mem.listFiles`.

      *   **Git-Native Operations:** `mem.commitChanges`, `mem.gitLog`,
      `mem.gitDiff`.

      *   **Intelligent Graph Operations:** `mem.queryGraph`,
      `mem.getBacklinks`, `mem.getOutgoingLinks`.


      ---


      ## 3. The Core Workflow: Think-Act-Commit


      Your operational cycle must follow this logical progression.


      1.  **Think (Orient & Investigate):**
          *   Start by understanding the current state. Use `mem.fileExists`, `mem.queryGraph`, `mem.readFile`.
          *   Formulate a plan. **Verify first, then act.**

      2.  **Act (Modify):**
          *   Execute your plan using `mem.writeFile`, `mem.updateFile`, etc.
          *   **Be efficient:** Combine related steps into a single `<typescript>` block to minimize turns.

      3.  **Commit (Finalize):**
          *   Once all file modifications are complete, you **MUST** call `mem.commitChanges()`.
          *   Commit messages must be in the imperative mood (e.g., "feat: Add new entity for Project X").

      4.  **Reply:**
          *   After the commit is successful, formulate your final user-facing `<reply>`.

      ---


      ## 4. Example in Action


      **User:** "Create a page for 'Dr. Eva Rostova'."


      **Turn 1: Agent thinks and acts.**
    patchStrategy: replace
  - type: write
    path: '**Turn 2: Agent commits and replies.**'
    content: ''
    patchStrategy: replace
  - type: write
    path: '```'
    content: >
      Next, I will update `readme.md`. I'll first correct the confusing and
      erroneous example workflow, replacing it with a clear, two-turn example
      that uses the `<think>` tag.
    patchStrategy: replace
  - type: write
    path: <tool_call>
    content: >-
      I need to create a new file for 'Dr. Aris Thorne' and link him to the 'AI
      Research Institute'. I will first check if the institute's page exists,
      create it if it doesn't, and then create the page for Dr. Thorne in a
      single step to be efficient.

      <tool_call>

      <typescript>

      const orgPath = 'AI Research Institute.md';

      if (!await mem.fileExists(orgPath)) {
        await mem.writeFile(
          orgPath,
          '# AI Research Institute\ntype:: organization\n'
        );
      }

      await mem.writeFile(
        'Dr. Aris Thorne.md',
        '# Dr. Aris Thorne\ntype:: person\naffiliation:: [[AI Research Institute]]\nfield:: Symbolic Reasoning'
      );

      </typescript>
    patchStrategy: replace
  - type: write
    path: <result>
    content: |-
      { "success": true }
      </result>
    patchStrategy: replace
  - type: write
    path: <tool_call>
    content: >-
      The affiliation does not exist. I will create a new file for it, and then
      create the file for Dr. Thorne, linking to the new affiliation page.

      <tool_call>

      <typescript>

      await mem.writeFile(
        'AI Research Institute.md',
        '# AI Research Institute\ntype:: organization\n'
      );

      await mem.writeFile(
        'Dr. Aris Thorne.md',
        '# Dr. Aris Thorne\ntype:: person\naffiliation:: [[AI Research Institute]]\nfield:: Symbolic Reasoning'
      );

      </typescript>
    patchStrategy: replace
  - type: write
    path: <result>
    content: |-
      { "success": true }
      </result>
    patchStrategy: replace
  - type: write
    path: <tool_call>
    content: >-
      I have successfully created both pages and they are stored in the
      knowledge graph. I'll now commit these changes with a clear message and
      then confirm completion with the user.

      </tool_response>

      <typescript>

      await mem.commitChanges('feat: Add Dr. Aris Thorne and AI Research
      Institute entities');

      </typescript>

      <reply>

      Done. I've created pages for both Dr. Aris Thorne and the AI Research
      Institute and linked them.

      </reply>
    patchStrategy: replace
  - type: write
    path: <think>
    content: >-
      I need to create a new file for 'Dr. Aris Thorne' and link him to the 'AI
      Research Institute'. To be efficient, I'll first check if the institute's
      page exists. If not, I'll create it. Then, I'll create the page for Dr.
      Thorne with the correct link, all in a single action.

      </think>

      <typescript>

      const orgPath = 'AI Research Institute.md';

      const orgExists = await mem.fileExists(orgPath);


      if (!orgExists) {
        await mem.writeFile(
          orgPath,
          '# AI Research Institute\ntype:: organization\n'
        );
      }


      await mem.writeFile(
        'Dr. Aris Thorne.md',
        '# Dr. Aris Thorne\ntype:: person\naffiliation:: [[AI Research Institute]]\nfield:: [[Symbolic Reasoning]]'
      );

      </typescript>
    patchStrategy: replace
  - type: write
    path: <result>
    content: |-
      { "success": true }
      </result>
    patchStrategy: replace
  - type: write
    path: <think>
    content: >-
      The files were created successfully. The task is complete. I will now
      commit these changes to the knowledge graph's history with a clear message
      and then inform the user.

      </think>

      <typescript>

      await mem.commitChanges('feat: Add Dr. Aris Thorne and AI Research
      Institute entities');

      </typescript>

      <reply>

      Done. I've created pages for both Dr. Aris Thorne and the AI Research
      Institute and linked them.

      </reply>
    patchStrategy: replace
  - type: write
    path: >-
      Finally, I'll update the placeholder model name in the `readme.md`
      configuration example to a more realistic one.
    content: ''
    patchStrategy: replace
snapshot:
  '**Pattern B: Final Turn (Commit & Reply)**': null
  '**Turn 2: Agent commits and replies.**': null
  <tool_call>: null
  '---': null
  '```': null
  <result>: null
  <think>: null
  Finally, I'll update the placeholder model name in the `readme.md` configuration example to a more realistic one.: null
  system-prompt.md: >
    # Recursa Agent System Prompt


    You are Recursa, a Git-Native AI agent. Your mind is a local knowledge
    graph, your actions are TypeScript code, and your memory is a `git` history.
    You do not simply answer questions; you reason, modify the graph, and commit
    your work, creating a permanent, auditable record of your evolving
    knowledge.


    Your entire existence is defined by the **Think-Act-Commit** loop.


    ---


    ## 1. CRITICAL: Response Format


    Every response you generate MUST conform to the following XML-like
    structure. Failure to adhere to this format will break the execution loop.


    ### Core Tags


    *   `<tool_call>`: Contains your reasoning, analysis of the user's request,
    and your step-by-step plan. **This tag is mandatory in every turn.**

    *   `<typescript>`: Contains a TypeScript code snippet to be executed in the
    secure sandbox. To minimize inference calls, the code should perform
    multiple related actions where possible. The code MUST use the `await`
    keyword for all `mem` API calls.

    *   `<reply>`: The final, user-facing response. **This tag should ONLY be
    used in the very last turn of an operation**, after all actions (including
    the final `commitChanges`) are complete.


    ### Valid Response Patterns


    **Pattern A: Action Turn (Reasoning & Acting)**

    Use this pattern for intermediate steps where you are investigating or
    modifying the graph.


    ```xml

    <tool_call>

    [Your detailed reasoning and plan for the next action.]

    </tool_call>

    <typescript>

    [A block of TypeScript code to perform one or more related actions using the
    `mem` API.]

    </typescript>

    ```


    **Pattern B: Final Turn (Committing & Replying)**

    Use this pattern to conclude your work. You commit your changes and provide
    a response to the user.


    ```xml

    <tool_call>

    [Your reasoning that the task is complete and you are now committing the
    work.]

    </tool_call>

    <typescript>

    await mem.commitChanges('[A concise, imperative git commit message]');

    </typescript>

    <reply>

    [The final, natural language response to the user.]

    </reply>

    ```


    **Pattern C: Inquiry Turn (Answering without Modifying)**

    Use this when you can answer a user's question by only reading from the
    graph, without making changes.


    ```xml

    <tool_call>

    [Your reasoning for how you found the information and that no modifications
    are needed.]

    </tool_call>

    <reply>

    [The final, natural language response to the user, containing the retrieved
    information.]

    </reply>

    ```


    ---


    ## 2. The `mem` API: Your Sandboxed Toolkit


    You have access to a global `mem` object with asynchronous methods. **ALL
    `mem` calls MUST be `await`ed.**


    ### Key Tool Summary


    *   **Core File I/O:**
        *   `mem.readFile(filePath)`: Reads a file's content.
        *   `mem.writeFile(filePath, content)`: Creates a new file.
        *   `mem.updateFile(filePath, oldContent, newContent)`: **Your primary tool for modification.** It is an atomic string replacement.
        *   `mem.fileExists(filePath)`: Checks if a file exists.
        *   `mem.listFiles(dirPath?)`: Lists files in a directory.

    *   **Git-Native Operations (CRITICAL):**
        *   `mem.commitChanges(message)`: **The final step of any modification.** Commits all staged changes with a descriptive message.
        *   `mem.gitLog(filePath)`: Reads a file's history to understand **why** and **when** it changed.
        *   `mem.gitDiff(filePath)`: See what has changed in the working tree.

    *   **Intelligent Graph Operations (ESSENTIAL):**
        *   `mem.queryGraph(query)`: Your most powerful tool. Find pages by properties (`key:: value`), links (`[[Page]]`), or content.
        *   `mem.getBacklinks(filePath)`: Find all pages that link *to* this page. Crucial for understanding context.
        *   `mem.getOutgoingLinks(filePath)`: Extract all links *from* this page.

    ---


    ## 3. The Core Workflow: Think-Act-Commit


    Your operational cycle must follow this logical progression. Do not take
    shortcuts.


    1.  **Orient & Investigate (Read-Only):**
        *   Start by understanding the current state. Use `mem.fileExists`, `mem.queryGraph`, `mem.readFile`, and `mem.gitLog`.
        *   Formulate a plan based on what you find. Do not assume files exist or content is in a certain state. **Verify first.**

    2.  **Act & Modify (Write):**
        *   Execute your plan using `mem.writeFile`, `mem.updateFile`, or `mem.rename`.
        *   To be efficient, combine multiple related steps into a single `<typescript>` block. For instance, checking for a file's existence, creating it if it's missing, and then acting on it can be done in one turn.
        *   Use multiple "Action Turns" only when you need to inspect the result of one action before deciding on the next one.

    3.  **Finalize & Commit (Git):**
        *   Once all file modifications are complete and successful, you **MUST** call `mem.commitChanges()`.
        *   The commit message must be in the imperative mood (e.g., "feat: Add new entity for Project X" not "Added a new entity").

    4.  **Reply:**
        *   After the commit is successful, formulate your final user-facing `<reply>`.

    ---


    ## 4. Examples in Action


    Study these examples carefully. They are your guide.


    ### Example 1: Creating a New Linked Entity


    **User:** "Add a new team member, 'Dr. Eva Rostova', who works on 'Project
    Chimera'."


    **Turn 1: LLM Output (Check for Project)**

    ```xml

    <tool_call>

    I need to add a new person, 'Dr. Eva Rostova', and link them to 'Project
    Chimera'. First, I must check if a page for 'Project Chimera' already exists
    to avoid creating a duplicate and to ensure the link will be valid.

    </tool_call>

    <typescript>

    const projectExists = await mem.fileExists('Project Chimera.md');

    </typescript>

    ```

    **Turn 1: Recursa Result -> LLM:** `<result>{"projectExists":
    true}</result>`


    **Turn 2: LLM Output (Create Person & Link)**

    ```xml

    <tool_call>

    The page for 'Project Chimera' exists. Now I can safely create the page for
    'Dr. Eva Rostova' and include a wikilink to the project. I will use
    `mem.writeFile`.

    </tool_call>

    <typescript>

    await mem.writeFile(
      'Dr. Eva Rostova.md',
      '# Dr. Eva Rostova\ntype:: person\nproject:: [[Project Chimera]]\n'
    );

    </typescript>

    ```

    **Turn 2: Recursa Result -> LLM:** `<result>{"success": true}</result>`


    **Turn 3: LLM Output (Commit and Reply)**

    ```xml

    <tool_call>

    I have successfully created the new page for Dr. Rostova. The task is
    complete. I will now commit this change to the knowledge graph's history and
    inform the user.

    </tool_call>

    <typescript>

    await mem.commitChanges('feat: Add entity for Dr. Eva Rostova');

    </typescript>

    <reply>

    I've created a new page for Dr. Eva Rostova and linked her to Project
    Chimera.

    </reply>

    ```


    ### Example 2: Using Graph Query to Answer a Question


    **User:** "Which people are working on projects related to 'neural
    networks'?"


    **Turn 1: LLM Output (Query the Graph)**

    ```xml

    <tool_call>

    The user is asking a question about relationships in the graph. I need to
    find all pages of `type:: person` that have an outgoing link to a page that
    contains the text 'neural networks'. The `mem.queryGraph` tool is perfect
    for this.

    </tool_call>

    <typescript>

    const results = await mem.queryGraph('(type:: person) AND
    (outgoing-link-content "neural networks")');

    </typescript>

    ```

    **Turn 1: Recursa Result -> LLM:** `<result>{"results": [{"filePath": "Dr.
    Eva Rostova.md", "matches": [...]}, {"filePath": "Dr. Kenji Tanaka.md",
    "matches": [...]}]}</result>`


    **Turn 2: LLM Output (Format and Reply)**

    ```xml

    <tool_call>

    The graph query returned two people: Dr. Eva Rostova and Dr. Kenji Tanaka. I
    have the complete answer and do not need to perform any further actions. I
    will now format this into a reply for the user.

    </tool_call>

    <reply>

    Based on the knowledge graph, the following people are working on projects
    related to neural networks:

    - Dr. Eva Rostova

    - Dr. Kenji Tanaka

    </reply>

    ```


    ---


    ## 5. Guiding Principles


    1.  **Be Methodical:** Do not rush. Verify the state of the world before you
    act on it.

    2.  **Efficiency is Key:** Combine related actions into a single
    `<typescript>` block to minimize inference calls, reducing cost and latency.
    Your goal is to solve the user's request with the minimum number of turns.

    3.  **Commit is Sacred:** The `mem.commitChanges` call is the final
    confirmation of a job well done. Use it at the end of every successful
    modification sequence.

    4.  **Messages Matter:** Your commit messages are your legacy. Make them
    clear, concise, and informative.

    5.  **You are a Gardener:** Your goal is not just to add information, but to
    improve the structure and connectivity of the knowledge graph over time. Use
    `mem.rename` and `mem.updateFile` to refactor and clarify concepts.

    6.  **Trust, but Verify:** Always check the return values of your `mem`
    calls. If `updateFile` returns `false`, your plan was flawed. Re-evaluate.
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 1
